# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tXAxySI4H_bDsiG-HqfMqPI1QQigJO21
"""

import os
import cv2
import numpy as np
from ultralytics import YOLO
import matplotlib.pyplot as plt
from pathlib import Path
import yaml
from shapely.geometry import Polygon
import matplotlib.patches as patches

class RulerDetector:
    def __init__(self, model_path=None):
        """
        Inicializa o detector de r√©gua para seu dataset espec√≠fico

        Args:
            model_path (str): Caminho para o modelo treinado. Se None, usa modelo base YOLOv11
        """
        if model_path and os.path.exists(model_path):
            self.model = YOLO(model_path)
            print(f"‚úÖ Modelo carregado de: {model_path}")
        else:
            # Usa modelo de segmenta√ß√£o para aproveitar coordenadas de pol√≠gono
            self.model = YOLO('yolo11n-seg.pt')
            print("üîÑ Modelo base YOLOv11n-seg carregado para treinamento")

        # Configura√ß√µes espec√≠ficas do seu dataset
        self.class_names = ['0', 'Penggaris', 'Penghapus', 'Pulpen']
        self.ruler_class_id = 1  # 'Penggaris' √© a classe 1 (r√©gua)

        print(f"üéØ Classes do dataset: {self.class_names}")
        print(f"üìè Classe da r√©gua: {self.class_names[self.ruler_class_id]} (ID: {self.ruler_class_id})")

    def verify_dataset_structure(self, dataset_path):
        """
        Verifica e exibe a estrutura do dataset
        """
        dataset_path = Path(dataset_path)
        print(f"\nüìÅ Verificando estrutura do dataset em: {dataset_path}")

        # Verifica pastas principais
        folders_found = {}
        for folder in ['train', 'valid', 'test']:
            folder_path = dataset_path / folder
            if folder_path.exists():
                images_path = folder_path / 'images'
                labels_path = folder_path / 'labels'

                img_count = len(list(images_path.glob('*'))) if images_path.exists() else 0
                lbl_count = len(list(labels_path.glob('*.txt'))) if labels_path.exists() else 0

                folders_found[folder] = {
                    'images': img_count,
                    'labels': lbl_count,
                    'images_exist': images_path.exists(),
                    'labels_exist': labels_path.exists()
                }

                print(f"  üìÇ {folder}/: {img_count} imagens, {lbl_count} labels")

        return folders_found

    def analyze_annotations(self, dataset_path, sample_size=5):
        """
        Analisa anota√ß√µes para entender o formato
        """
        dataset_path = Path(dataset_path)
        print(f"\nüîç Analisando formato das anota√ß√µes...")

        # Procura arquivos de anota√ß√£o
        label_files = []
        for folder in ['train', 'valid']:
            labels_path = dataset_path / folder / 'labels'
            if labels_path.exists():
                label_files.extend(list(labels_path.glob('*.txt'))[:sample_size])

        if not label_files:
            print("‚ùå Nenhum arquivo de anota√ß√£o encontrado!")
            return

        annotation_info = {
            'total_files_analyzed': 0,
            'classes_found': set(),
            'ruler_annotations': 0,
            'sample_annotations': []
        }

        for label_file in label_files[:sample_size]:
            if not label_file.exists():
                continue

            annotation_info['total_files_analyzed'] += 1

            with open(label_file, 'r') as f:
                lines = f.readlines()

            for line in lines:
                if line.strip():
                    parts = list(map(float, line.strip().split()))
                    class_id = int(parts[0])
                    coords = parts[1:]

                    annotation_info['classes_found'].add(class_id)

                    if class_id == self.ruler_class_id:
                        annotation_info['ruler_annotations'] += 1

                        if len(annotation_info['sample_annotations']) < 2:
                            annotation_info['sample_annotations'].append({
                                'file': label_file.name,
                                'class_id': class_id,
                                'num_points': len(coords) // 2,
                                'coords_sample': coords[:8]  # Primeiros 4 pontos
                            })

        # Exibe resultados da an√°lise
        print(f"üìä Arquivos analisados: {annotation_info['total_files_analyzed']}")
        print(f"üè∑Ô∏è Classes encontradas: {sorted(annotation_info['classes_found'])}")
        print(f"üìè Anota√ß√µes de r√©gua encontradas: {annotation_info['ruler_annotations']}")

        for sample in annotation_info['sample_annotations']:
            print(f"  üìù {sample['file']}: Classe {sample['class_id']}, {sample['num_points']} pontos")

        return annotation_info

    def setup_dataset(self, dataset_path):
        """
        Configura o dataset para treinamento
        """
        self.dataset_path = Path(dataset_path)

        # Verifica estrutura
        self.verify_dataset_structure(dataset_path)

        # Analisa anota√ß√µes
        self.analyze_annotations(dataset_path)

        # Verifica/cria data.yaml
        config_path = self.dataset_path / "data.yaml"
        if config_path.exists():
            print(f"‚úÖ Arquivo data.yaml encontrado")
            # Verifica se est√° correto
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
            print(f"   - Classes: {config.get('names', 'n√£o encontradas')}")
        else:
            print("üìù Criando arquivo data.yaml...")
            self.create_dataset_config(config_path)

        return str(config_path)

    def create_dataset_config(self, config_path):
        """
        Cria arquivo de configura√ß√£o do dataset baseado na sua estrutura
        """
        config = {
            'path': str(self.dataset_path.absolute()),
            'train': 'train/images',
            'val': 'valid/images',
            'test': 'test/images',
            'nc': 4,
            'names': ['0', 'Penggaris', 'Penghapus', 'Pulpen']
        }

        with open(config_path, 'w') as f:
            yaml.dump(config, f, default_flow_style=False)

        print(f"‚úÖ Arquivo data.yaml criado: {config_path}")

    def train_model(self, dataset_path, epochs=100, img_size=640, batch_size=8, patience=20):
        """
        Treina o modelo de segmenta√ß√£o
        """
        print("üöÄ Iniciando treinamento do modelo de segmenta√ß√£o...")

        # Configura dataset
        config_file = self.setup_dataset(dataset_path)

        try:
            # Treina o modelo
            results = self.model.train(
                data=config_file,
                epochs=epochs,
                imgsz=img_size,
                batch=batch_size,
                name='ruler_segmentation',
                save=True,
                plots=True,
                patience=patience,
                device='cpu'  # Usa GPU se dispon√≠vel
            )

            model_path = "runs/segment/ruler_segmentation/weights/best.pt"
            print(f"‚úÖ Treinamento conclu√≠do!")
            print(f"üìÅ Modelo salvo em: {model_path}")

            return results

        except Exception as e:
            print(f"‚ùå Erro durante treinamento: {e}")
            print("üí° Dicas para resolver:")
            print("  - Verifique se as imagens e labels est√£o nas pastas corretas")
            print("  - Reduza o batch_size se houver erro de mem√≥ria")
            print("  - Verifique se o dataset est√° no formato correto")
            raise

    def load_trained_model(self, model_path):
        """
        Carrega modelo j√° treinado
        """
        if not os.path.exists(model_path):
            print(f"‚ùå Modelo n√£o encontrado: {model_path}")
            return False

        self.model = YOLO(model_path)
        print(f"‚úÖ Modelo carregado: {model_path}")
        return True

    def calculate_polygon_area_shoelace(self, points):
        """
        Calcula √°rea de pol√≠gono usando f√≥rmula Shoelace
        Mais precisa que usar apenas bounding box
        """
        if len(points) < 6:  # Precisa de pelo menos 3 pontos (6 coordenadas)
            return 0

        # Organiza pontos em pares (x, y)
        coords = []
        for i in range(0, len(points), 2):
            if i + 1 < len(points):
                coords.append([points[i], points[i + 1]])

        if len(coords) < 3:
            return 0

        # F√≥rmula Shoelace
        area = 0
        n = len(coords)
        for i in range(n):
            j = (i + 1) % n
            area += coords[i][0] * coords[j][1]
            area -= coords[j][0] * coords[i][1]

        return abs(area) / 2

    def detect_ruler(self, image_path, conf_threshold=0.3, save_crops=False):
        """
        Detecta r√©gua na imagem e calcula √°rea real do pol√≠gono
        """
        if not os.path.exists(image_path):
            return {"error": f"Imagem n√£o encontrada: {image_path}"}

        print(f"üîç Analisando imagem: {Path(image_path).name}")

        # Faz predi√ß√£o
        results = self.model(image_path, conf=conf_threshold, save_crop=save_crops)

        # Carrega imagem para obter dimens√µes
        image = cv2.imread(image_path)
        if image is None:
            return {"error": f"N√£o foi poss√≠vel carregar a imagem"}

        img_height, img_width = image.shape[:2]

        detection_info = {
            "image_path": image_path,
            "image_dimensions": {"width": img_width, "height": img_height},
            "ruler_detected": False,
            "ruler_detections": [],
            "all_detections": [],
            "total_ruler_area_pixels": 0,
            "confidence_threshold": conf_threshold
        }

        # Processa resultados
        for result in results:
            if result.boxes is not None:
                for i, box in enumerate(result.boxes):
                    class_id = int(box.cls[0].cpu().numpy())
                    confidence = float(box.conf[0].cpu().numpy())
                    x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()

                    # Informa√ß√µes b√°sicas da detec√ß√£o
                    detection = {
                        "class_id": class_id,
                        "class_name": self.class_names[class_id],
                        "confidence": confidence,
                        "bbox": [int(x1), int(y1), int(x2), int(y2)],
                        "bbox_area_pixels": int((x2 - x1) * (y2 - y1))
                    }

                    # Tenta obter m√°scara de segmenta√ß√£o
                    if (hasattr(result, 'masks') and
                        result.masks is not None and
                        i < len(result.masks.xy)):

                        # Coordenadas da m√°scara (j√° em pixels)
                        mask_coords = result.masks.xy[i]
                        if len(mask_coords) > 0:
                            # Converte para lista de coordenadas
                            coords_flat = mask_coords.flatten().tolist()
                            detection["segmentation_coords"] = coords_flat
                            detection["num_points"] = len(coords_flat) // 2

                            # Calcula √°rea real do pol√≠gono
                            polygon_area = self.calculate_polygon_area_shoelace(coords_flat)
                            detection["polygon_area_pixels"] = int(polygon_area)

                            print(f"  üéØ {detection['class_name']}: {detection['num_points']} pontos, √°rea: {polygon_area:.0f} px")

                    detection_info["all_detections"].append(detection)

                    # Se √© r√©gua, adiciona √†s detec√ß√µes de r√©gua
                    if class_id == self.ruler_class_id:
                        detection_info["ruler_detected"] = True
                        detection_info["ruler_detections"].append(detection)

                        # Soma √°rea (usa pol√≠gono se dispon√≠vel, sen√£o bbox)
                        area = detection.get("polygon_area_pixels", detection["bbox_area_pixels"])
                        detection_info["total_ruler_area_pixels"] += area

        # Resumo final
        if detection_info["ruler_detected"]:
            print(f"‚úÖ {len(detection_info['ruler_detections'])} r√©gua(s) detectada(s)")
            print(f"üìê √Årea total: {detection_info['total_ruler_area_pixels']} pixels")
        else:
            print("‚ùå Nenhuma r√©gua detectada")

        print(f"üìä Total de objetos: {len(detection_info['all_detections'])}")

        return detection_info

    def visualize_detection(self, image_path, detection_info, save_path=None, show_all_objects=True):
        """
        Visualiza resultados com pol√≠gonos precisos
        """
        image = cv2.imread(image_path)
        image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

        fig, ax = plt.subplots(1, 1, figsize=(16, 12))
        ax.imshow(image_rgb)

        # Cores para cada classe
        class_colors = {
            0: 'blue',
            1: 'red',      # R√©gua
            2: 'green',    # Borracha
            3: 'orange'    # Caneta
        }

        # Desenha todas as detec√ß√µes
        for detection in detection_info["all_detections"]:
            class_id = detection["class_id"]
            is_ruler = (class_id == self.ruler_class_id)
            color = class_colors.get(class_id, 'purple')

            # Desenha bounding box
            x1, y1, x2, y2 = detection["bbox"]
            linewidth = 4 if is_ruler else 2
            linestyle = '-' if is_ruler else '--'

            rect = patches.Rectangle((x1, y1), x2-x1, y2-y1,
                                   linewidth=linewidth, edgecolor=color,
                                   facecolor='none', linestyle=linestyle)
            ax.add_patch(rect)

            # Desenha pol√≠gono de segmenta√ß√£o se dispon√≠vel
            if "segmentation_coords" in detection:
                coords = detection["segmentation_coords"]
                # Converte coordenadas planas para pontos (x,y)
                points = []
                for i in range(0, len(coords), 2):
                    if i + 1 < len(coords):
                        points.append([coords[i], coords[i + 1]])

                if len(points) >= 3:
                    polygon = MplPolygon(points, closed=True, fill=False,
                                       edgecolor=color, linewidth=3, alpha=0.8)
                    ax.add_patch(polygon)

            # Informa√ß√µes do texto
            confidence = detection["confidence"]
            bbox_area = detection["bbox_area_pixels"]
            polygon_area = detection.get("polygon_area_pixels", None)

            # Monta texto informativo
            if is_ruler:
                if polygon_area:
                    text = f'üéØ R√âGUA\nConf: {confidence:.2f}\n√Årea real: {polygon_area:,} px\nBBox: {bbox_area:,} px'
                    text_color = 'white'
                    bg_color = 'red'
                    alpha = 0.9
                else:
                    text = f'üìè R√âGUA\nConf: {confidence:.2f}\n√Årea: {bbox_area:,} px'
                    text_color = 'white'
                    bg_color = 'red'
                    alpha = 0.8
            else:
                if show_all_objects:
                    area_text = f'{polygon_area:,}' if polygon_area else f'{bbox_area:,}'
                    text = f'{detection["class_name"]}\n{confidence:.2f}\n{area_text} px'
                    text_color = 'white'
                    bg_color = color
                    alpha = 0.7
                else:
                    continue  # Pula objetos que n√£o s√£o r√©gua

            # Posiciona texto
            text_y = y1 - 10 if y1 > 50 else y2 + 10
            ax.text(x1, text_y, text,
                   bbox=dict(boxstyle="round,pad=0.5", facecolor=bg_color, alpha=alpha),
                   fontsize=11, color=text_color, weight='bold')

        # T√≠tulo da imagem
        title = f"üì∑ {Path(image_path).name}\n"

        if detection_info["ruler_detected"]:
            ruler_count = len(detection_info["ruler_detections"])
            total_area = detection_info["total_ruler_area_pixels"]
            title += f"‚úÖ {ruler_count} R√©gua(s) Detectada(s) - √Årea Total: {total_area:,} pixels"
        else:
            title += "‚ùå Nenhuma R√©gua Detectada"

        total_objects = len(detection_info["all_detections"])
        title += f"\nüìä Total de Objetos: {total_objects}"

        ax.set_title(title, fontsize=14, weight='bold', pad=20)
        ax.axis('off')

        plt.tight_layout()

        if save_path:
            plt.savefig(save_path, bbox_inches='tight', dpi=200)
            print(f"üíæ Resultado salvo em: {save_path}")

        plt.show()

    def batch_process(self, images_folder, output_folder=None):
        """
        Processa m√∫ltiplas imagens
        """
        images_folder = Path(images_folder)
        image_extensions = ['.jpg', '.jpeg', '.png', '.bmp', '.tiff']

        if output_folder:
            output_folder = Path(output_folder)
            output_folder.mkdir(exist_ok=True)

        results = []
        total_ruler_area = 0
        images_with_rulers = 0

        print(f"\nüîÑ Processando imagens em: {images_folder}")

        image_files = [f for f in images_folder.iterdir()
                      if f.suffix.lower() in image_extensions]

        for i, img_file in enumerate(image_files, 1):
            print(f"\nüì∏ [{i}/{len(image_files)}] {img_file.name}")

            # Detecta objetos
            detection_result = self.detect_ruler(str(img_file))
            detection_result["filename"] = img_file.name
            results.append(detection_result)

            # Atualiza estat√≠sticas
            if detection_result["ruler_detected"]:
                images_with_rulers += 1
                total_ruler_area += detection_result["total_ruler_area_pixels"]

            # Salva visualiza√ß√£o se solicitado
            if output_folder:
                save_path = output_folder / f"resultado_{img_file.name}"
                self.visualize_detection(str(img_file), detection_result, str(save_path))

        # Resumo final
        print(f"\nüìä === RESUMO DO PROCESSAMENTO ===")
        print(f"üñºÔ∏è Imagens processadas: {len(image_files)}")
        print(f"üìè Imagens com r√©guas: {images_with_rulers}")
        print(f"üìê √Årea total de r√©guas: {total_ruler_area:,} pixels")

        if images_with_rulers > 0:
            avg_area = total_ruler_area / images_with_rulers
            print(f"üìä √Årea m√©dia por imagem: {avg_area:.0f} pixels")

        return results

def main():
    print("üéØ === DETECTOR DE R√âGUA - VERS√ÉO OTIMIZADA ===")
    print("üìã Adaptado especificamente para seu dataset com 4 classes")

    # Configura√ß√£o
    dataset_path = "/content/drive/MyDrive/MC854/DeteksiPerlengkapanSeklah.v2i.yolov11"  # Substitua pelo caminho real
    test_image = "/content/11T8.JPG"  # Substitua pelo caminho real

    print(f"\nüîß EXEMPLO DE USO:")
    print(f"1Ô∏è‚É£ TREINAMENTO:")
    print(f"   detector = RulerDetector()")
    print(f"   results = detector.train_model('{dataset_path}', epochs=50)")

    print(f"\n2Ô∏è‚É£ DETEC√á√ÉO:")
    print(f"   detector.load_trained_model('runs/segment/ruler_segmentation/weights/best.pt')")
    print(f"   result = detector.detect_ruler('{test_image}')")
    print(f"   detector.visualize_detection('{test_image}', result)")

    print(f"\nüí° CARACTER√çSTICAS:")
    print(f"   ‚úÖ Detecta todas as 4 classes do seu dataset")
    print(f"   ‚úÖ Calcula √°rea REAL da r√©gua (pol√≠gono, n√£o ret√¢ngulo)")
    print(f"   ‚úÖ Visualiza√ß√£o com contornos precisos")
    print(f"   ‚úÖ Processamento em lote de m√∫ltiplas imagens")

    # Exemplo pr√°tico (descomente para usar)

    # Inicializa detector
    detector = RulerDetector()

    # Treina modelo
    results = detector.train_model(
        dataset_path=dataset_path,
        epochs=50,
        batch_size=8,
        patience=10
    )

    # Testa em imagem
    detector.load_trained_model("runs/segment/ruler_segmentation/weights/best.pt")
    result = detector.detect_ruler(test_image)
    detector.visualize_detection(test_image, result)

    print(f"R√©gua detectada: {result['ruler_detected']}")
    print(f"√Årea da r√©gua: {result['total_ruler_area_pixels']} pixels")

if __name__ == "__main__":
    print()

    main()