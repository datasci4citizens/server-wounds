import os
from PIL import Image, ImageChops
import numpy as np
import pandas as pd
from sklearn.cluster import KMeans
from torchvision import models, transforms
import torch
from tqdm import tqdm

# Paths (relative to this script)
images_dir = "identification_model/validation/images"
labels_dir = "identification_model/validation/labels"
output_csv = "identification_model/validation/wound_clusters.csv"

# Image preprocessing (ResNet18-compatible)
preprocess = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Load pretrained ResNet18 and remove classifier
resnet = models.resnet18(pretrained=True)
resnet = torch.nn.Sequential(*list(resnet.children())[:-1])
resnet.eval().to("cpu")

# Collect image features
features = []
filenames = []

for filename in tqdm(sorted(os.listdir(images_dir))):
    if not filename.lower().endswith(('.jpg', '.jpeg', '.png')):
        continue

    img_path = os.path.join(images_dir, filename)
    mask_path = os.path.join(labels_dir, filename)

    if not os.path.exists(mask_path):
        continue

    # Load and apply mask
    img = Image.open(img_path).convert("RGB")
    mask = Image.open(mask_path).convert("L")
    mask_bin = mask.point(lambda p: 255 if p > 127 else 0)
    masked_img = ImageChops.multiply(img, Image.merge("RGB", [mask_bin]*3))

    # Transform and extract features
    input_tensor = preprocess(masked_img).unsqueeze(0)
    with torch.no_grad():
        embedding = resnet(input_tensor).squeeze().numpy()
        features.append(embedding)
        filenames.append(filename)

# Cluster feature vectors
X = np.stack(features)
kmeans = KMeans(n_clusters=4, random_state=42)
clusters = kmeans.fit_predict(X)

# Save cluster assignments
df = pd.DataFrame({'filename': filenames, 'cluster': clusters})
df.to_csv(output_csv, index=False)
print(f"[âœ“] Cluster results saved to: {output_csv}")
